
function capitalize<T extends string>(str: T): Capitalize<T> {
  return `${str.charAt(0).toUpperCase()}${str.substring(1)}` as Capitalize<T>;
}

function createFormContextName<Name extends string>(
  name: Name
): ToFormContextName<Name> {
  return `${capitalize(name)}FormContext` as ToFormContextName<Name>;
}

function createFormContextHookName<Name extends string>(
  name: Name
): ToFormContextHookName<Name> {
  return `use${createFormContextName(name)}`;
}

function createFormContext<Name extends string, Form extends object>(
  name: Name
): FormContextCreator<Name, Form> {
  const context = createContext({} as any);

  const useHook = () => useContext(context);

  return {
    [createFormContextName(name)]: context,
    [createFormContextHookName(name)]: useHook,
  } as FormContextCreator<Name, Form>;
}

type ToFormContextName<Name extends string> = `${Capitalize<Name>}FormContext`;
type ToFormContextHookName<Name extends string> =
  `use${ToFormContextName<Name>}`;

type FormContextCreator<Name extends string, Form extends object> = {
  [key in ToFormContextName<Name>]: any;
} & {
  [key in ToFormContextHookName<Name>]: () => any;
};

type TestFormName = "basicLogIn";

type Test1 = ToFormContextName<TestFormName>;
type Test2 = ToFormContextHookName<TestFormName>;
type Test3 = FormContextCreator<TestFormName, any>;

const creator = createFormContext("basicLogIn");
const context = creator.BasicLogInFormContext;
const hook = creator.useBasicLogInFormContext;
// export function createFormContext() {
//   const FormContext = createContext(null);

//   const FormProvider = ({ form, children }) => (
//     <FormContext.Provider value={form}>{children}</FormContext.Provider>
//   );

//   const useFormContext = () => {
//     const context = useContext(FormContext);
//     if (!context) {
//       throw new Error('useFormContext must be used within a FormProvider');
//     }
//     return context;
//   };

//   return { FormProvider, useFormContext };
// }


/////////////////////////////////////////////////
"use client";

import React from "react";
import * as z from "zod";
import * as v from "valibot";
import { Button, Checkbox, Stack, TextInput } from "@mantine/core";
import { Field, useForm } from "@tanstack/react-form";

import {
  prefixSchemaToErrors,
  valibotValidator,
} from "@tanstack/valibot-form-adapter";

interface BasicLogInForm {
  username: string;
  // password: string;
}

const usernameFormatValidationSchema = v.pipe(
  v.string(),
  v.nonEmpty("[Field] Value is required"),
  v.minLength(3, "[Field] Value must have a length of at least 3"),
  v.maxLength(10, "[Field] Value must have a length of at most 10")
);

const onChangeSchemaValibot = v.object({
  username: usernameFormatValidationSchema,
});

const onSubmitValidationSchema = v.object({
  hasAgreedToTermsOfService: v.pipe(
    v.boolean(),
    v.literal(true, "[Form] You must agree to the Terms of Service")
  ),
});

// const usernameSchemaZod = z.object({
//   username: z.string().min(3, "You must have a length of at least 3"),
// });

export default function BasicLogInForm() {
  // const usernameSchemaZod = z.object({
  //   username: z.string().min(3, "You must have a length of at least 3"),
  // });

  const { Field, handleSubmit, state, Subscribe } = useForm({
    defaultValues: {
      username: "",
      hasAgreedToTermsOfService: false,
    },
    validatorAdapter: valibotValidator(),
    validators: {
      onChange: onChangeSchemaValibot,
      onSubmit: onSubmitValidationSchema,
    }
    // validatorAdapter: valibotValidator({
    //   transformErrors: (errors) => {
    //     console.log(errors);
    //     return errors.map((errors) => errors.message).join(", ");
    //   },
    // }),

    // validators: {
    //   onSubmit: ({ value }) => {
    //     console.log(
    //       `%cValidating data:`,
    //       `background: gold; color: darkslategray `
    //     );

    //     // try {
    //     //   v.parse(usernameSchemaValibot, value);
    //     // } catch (error) {
    //     //   console.log({ error });
    //     //   return "there was an error";
    //     // }

    //     const result = v.safeParse(onChangeSchemaValibot, value);
    //     console.log({ result });
    //     console.log(result.issues);

    //     return {
    //       form:
    //         value.username === "username"
    //           ? "[Form] Username can not be 'username'"
    //           : false,
    //       fields: prefixSchemaToErrors(result.issues ?? [], (issues) =>
    //         issues.map((issue) => issue.message).join(", ")
    //       ),
    //     };

    //     // return usernameSchemaValibot
    //   },
    // },
    // validators: {
    //   onSubmit: ({ value }) => {
    //     console.log({ value });
    //     if (value.username === "username") {
    //       console.log("not right");
    //       return {
    //         form: "[Form] Please fill in all fields",
    //         fields: {},
    //       };
    //     }

    //     return usernameSchemaValibot;
    //   },
    // },
    onSubmit: async ({ value }) => {
      // Handle form submission
      console.log(
        `%cSubmitting data:`,
        `background: lightgreen; color: darkslategray `
      );
      console.log(value);
    },
  });

  return (
    <>
      <form
        onSubmit={(e) => {
          e.preventDefault();
          handleSubmit();
        }}
      >
        <Stack>
          <Field name={"username"}>
            {({ state, handleChange, handleBlur }) => (
              <TextInput
                label="Username"
                placeholder="Enter your username"
                onChange={(e) => handleChange(e.target.value)}
                onBlur={handleBlur}
                defaultValue={state.value}
                error={state.meta.errors?.[0]}
              />
            )}
          </Field>

          <Field name={"hasAgreedToTermsOfService"}>
            {({ state, handleChange, handleBlur }) => (
              <Checkbox
                label="I agree to the terms of service"
                labelPosition="right"
                checked={state.value}
                onChange={(e) => {
                  handleChange(e.target.checked);
                }}
                onBlur={handleBlur}
              />
            )}
          </Field>

          <Button type="submit">Submit</Button>
        </Stack>
      </form>

      <section>
        <h2>Submitted values:</h2>
        <pre>{JSON.stringify(state.values, null, 2)}</pre>
      </section>

      <section>
        <h2>Form errors:</h2>
        <pre>{JSON.stringify(state.errors, null, 2)}</pre>
        <Subscribe
          selector={(s) => s.errors}
          children={(errors) => {
            return <pre>{JSON.stringify(errors, null, 2)}</pre>;
          }}
        />
      </section>
    </>
  );
}

export function BasicLogInFormFields() {
  // const { foo } = useBasicLogInForm();
  // console.log(foo);

  return (
    <>
      {/* <UsernameField /> */}
      {/* <PasswordField /> */}
    </>
  );
}

function UsernameField({
  name = "username",
  form,
}: {
  name: string;
  form: any;
}) {
  // const field = useField({ name });
  // const form = useFormCon;
  return (
    <Field form={form} name={name}>
      {({ state, handleChange, handleBlur }) => (
        <input
          onChange={handleChange}
          onBlur={handleBlur}
          defaultValue={state.value as string}
        />
      )}
    </Field>
  );
}

function PasswordField() {
  return <input />;
}

export function Test() {
  const { Field, handleSubmit, state } = useForm({
    defaultValues: {
      firstName: "",
      lastName: "",
      isChecked: false,
    },
    onSubmit: async ({ value }) => {
      // Handle form submission
      console.log(value);
    },
  });

  return (
    <>
      <form
        onSubmit={(e) => {
          e.preventDefault();
          handleSubmit();
        }}
      >
        <Field
          name="firstName"
          children={({ state, handleChange, handleBlur }) => (
            <input
              onChange={(e) => handleChange(e.target.value)}
              onBlur={handleBlur}
              defaultValue={state.value}
            />
          )}
        />
        {/* <Field
            name="isChecked"
            children={({ state, handleChange, handleBlur }) => (
              <Checkbox
                onChange={(e) => handleChange(e.target.checked)}
                onBlur={handleBlur}
                checked={state.value}
              />
            )}
          /> */}
      </form>
      <div>
        <pre>{JSON.stringify(state.values, null, 2)}</pre>
      </div>
    </>
  );
}
/////////////////////////////////////////////////



/////////////////////////////////////////////////

"use client";

import React from "react";
import * as z from "zod";
import * as v from "valibot";
import { Button, Checkbox, Stack, TextInput } from "@mantine/core";
import { Field, useForm } from "@tanstack/react-form";

import { zodValidator } from "@tanstack/zod-form-adapter";
import {
  prefixSchemaToErrors,
  valibotValidator,
} from "@tanstack/valibot-form-adapter";

interface BasicLogInForm {
  username: string;
  // password: string;
}

interface BasicForm {
  username: string;
  hasAgreedToTermsOfService: boolean;
}

const usernameFormatValidationSchema = v.pipe(
  v.string(),
  v.trim(),
  v.nonEmpty("[Field] Value is required"),
  v.minLength(3, "[Field] Value must have a length of at least 3"),
  v.maxLength(10, "[Field] Value must have a length of at most 10"),
  v.check((input) => input !== "admin", "[Field] Value can not be 'admin'")
);

const onChangeSchemaValibot = v.object({
  username: usernameFormatValidationSchema,
}) satisfies v.GenericSchema<Pick<BasicForm, "username">>;

const onSubmitValidationSchema = v.object({
  hasAgreedToTermsOfService: v.pipe(
    v.boolean(),
    v.literal(true, "[Form] You must agree to the Terms of Service")
  ),
}) satisfies v.GenericSchema<Pick<BasicForm, "hasAgreedToTermsOfService">>;

// const usernameFormatValidationSchema = z
//   .string()
//   .trim()
//   .min(1, "[Field] Value is required")
//   .min(3, "[Field] Value must have a length of at least 3")
//   .max(10, "[Field] Value must have a length of at most 10")
//   .refine(
//     (arg) => arg.toLowerCase() !== "admin",
//     "[Field] Value can not be 'admin'"
//   );

// const onChangeSchemaValibot = z.object({
//   username: usernameFormatValidationSchema,
// }) satisfies z.ZodType<Pick<BasicForm, 'username'>>;

// const onSubmitValidationSchema = z.object({
//   hasAgreedToTermsOfService: z
//     .boolean({
//       required_error: "required_error",
//     })
//     .refine(
//       (arg) => arg !== true,
//       "[Form] You must agree to the Terms of Service"
//     ),
// });

// const usernameSchemaZod = z.object({
//   username: z.string().min(3, "You must have a length of at least 3"),
// });

export default function BasicLogInForm() {
  // const usernameSchemaZod = z.object({
  //   username: z.string().min(3, "You must have a length of at least 3"),
  // });

  const { Field, handleSubmit, state, Subscribe } = useForm({
    defaultValues: {
      username: "",
      hasAgreedToTermsOfService: false,
    },
    // validatorAdapter: zodValidator(),
    // validators: {
    //   onChange: onChangeSchemaValibot,
    //   onSubmit: onSubmitValidationSchema,
    // },

    validatorAdapter: valibotValidator(),
    validators: {
      onChange: onChangeSchemaValibot,
      onSubmit: onSubmitValidationSchema,
    },
    // validatorAdapter: valibotValidator({
    //   transformErrors: (errors) => {
    //     console.log(errors);
    //     return errors.map((errors) => errors.message).join(", ");
    //   },
    // }),

    // validators: {
    //   onSubmit: ({ value }) => {
    //     console.log(
    //       `%cValidating data:`,
    //       `background: gold; color: darkslategray `
    //     );

    //     // try {
    //     //   v.parse(usernameSchemaValibot, value);
    //     // } catch (error) {
    //     //   console.log({ error });
    //     //   return "there was an error";
    //     // }

    //     const result = v.safeParse(onChangeSchemaValibot, value);
    //     console.log({ result });
    //     console.log(result.issues);

    //     return {
    //       form:
    //         value.username === "username"
    //           ? "[Form] Username can not be 'username'"
    //           : false,
    //       fields: prefixSchemaToErrors(result.issues ?? [], (issues) =>
    //         issues.map((issue) => issue.message).join(", ")
    //       ),
    //     };

    //     // return usernameSchemaValibot
    //   },
    // },
    // validators: {
    //   onSubmit: ({ value }) => {
    //     console.log({ value });
    //     if (value.username === "username") {
    //       console.log("not right");
    //       return {
    //         form: "[Form] Please fill in all fields",
    //         fields: {},
    //       };
    //     }

    //     return usernameSchemaValibot;
    //   },
    // },
    onSubmit: async ({ value }) => {
      // Handle form submission
      console.log(
        `%cSubmitting data:`,
        `background: lightgreen; color: darkslategray `
      );
      console.log(value);
    },
  });

  return (
    <>
      <form
        onSubmit={(e) => {
          e.preventDefault();
          handleSubmit();
        }}
      >
        <Stack>
          <Field name={"username"}>
            {({ state, handleChange, handleBlur }) => (
              <TextInput
                label="Username"
                placeholder="Enter your username"
                onChange={(e) => handleChange(e.target.value)}
                onBlur={handleBlur}
                defaultValue={state.value}
                error={state.meta.errors?.[0]}
              />
            )}
          </Field>

          <Field name={"hasAgreedToTermsOfService"}>
            {({ state, handleChange, handleBlur }) => (
              <Checkbox
                label="I agree to the terms of service"
                labelPosition="right"
                checked={state.value}
                onChange={(e) => {
                  handleChange(e.target.checked);
                }}
                onBlur={handleBlur}
              />
            )}
          </Field>

          <Button type="submit">Submit</Button>
        </Stack>
      </form>

      <section>
        <h2>Submitted values:</h2>
        <pre>{JSON.stringify(state.values, null, 2)}</pre>
      </section>

      <section>
        <h2>Form errors:</h2>
        <pre>{JSON.stringify(state.errors, null, 2)}</pre>
        <Subscribe
          selector={(s) => s.errors}
          children={(errors) => {
            return <pre>{JSON.stringify(errors, null, 2)}</pre>;
          }}
        />
      </section>
    </>
  );
}

export function BasicLogInFormFields() {
  // const { foo } = useBasicLogInForm();
  // console.log(foo);

  return (
    <>
      {/* <UsernameField /> */}
      {/* <PasswordField /> */}
    </>
  );
}

function UsernameField({
  name = "username",
  form,
}: {
  name: string;
  form: any;
}) {
  // const field = useField({ name });
  // const form = useFormCon;
  return (
    <Field form={form} name={name}>
      {({ state, handleChange, handleBlur }) => (
        <input
          onChange={handleChange}
          onBlur={handleBlur}
          defaultValue={state.value as string}
        />
      )}
    </Field>
  );
}

function PasswordField() {
  return <input />;
}

export function Test() {
  const { Field, handleSubmit, state } = useForm({
    defaultValues: {
      firstName: "",
      lastName: "",
      isChecked: false,
    },
    onSubmit: async ({ value }) => {
      // Handle form submission
      console.log(value);
    },
  });

  return (
    <>
      <form
        onSubmit={(e) => {
          e.preventDefault();
          handleSubmit();
        }}
      >
        <Field
          name="firstName"
          children={({ state, handleChange, handleBlur }) => (
            <input
              onChange={(e) => handleChange(e.target.value)}
              onBlur={handleBlur}
              defaultValue={state.value}
            />
          )}
        />
        {/* <Field
            name="isChecked"
            children={({ state, handleChange, handleBlur }) => (
              <Checkbox
                onChange={(e) => handleChange(e.target.checked)}
                onBlur={handleBlur}
                checked={state.value}
              />
            )}
          /> */}
      </form>
      <div>
        <pre>{JSON.stringify(state.values, null, 2)}</pre>
      </div>
    </>
  );
}


/////////////////////////////////////////////////




/////////////////////////////////////////////////


<Stack component={"section"}>
            <Title order={2}>Submitted values:</Title>
            <Subscribe
              selector={(s) => ({
                isSubmitted: s.isSubmitted,
                submissionAttempts: s.submissionAttempts,
              })}
            >
              {({ isSubmitted, submissionAttempts }) =>
                isSubmitted ? (
                  <Code block>{JSON.stringify(state.values, null, 2)}</Code>
                ) : submissionAttempts === 0 ? (
                  <Alert title="Information">Form is not submitted</Alert>
                ) : (
                  <Alert title="Failure" color="red">
                    Form failed to submit
                  </Alert>
                )
              }
            </Subscribe>
          </Stack>

          <Stack component={"section"}>
            <Title order={2}>Validation</Title>

            <Subscribe
              selector={(s) => [s.errors, s.errorMap]}
              children={([errors, errorMap]) => {
                console.log({ errors, errorMap });

                return (
                  <div>
                    <Alert
                      title="Form errors"
                      withCloseButton
                      closeButtonLabel="Dismiss"
                      color="red"
                    >
                      <pre>
                        {JSON.stringify(
                          (errors as any).length ? errors : [],
                          null,
                          2
                        )}
                      </pre>
                    </Alert>
                  </div>
                );
              }}

              // selector={(s) =>
              //   [s.errors, s.isPristine] as [ValidationError[], boolean]
              // }
              // children={([errors, isPristine]) => {
              //   if (isPristine)
              //     return (
              //       <Alert title="Information">Form is in pristine state</Alert>
              //     );

              //   if (errors.length === 0)
              //     return (
              //       <Alert color="green" title="Success">
              //         No validation errors
              //       </Alert>
              //     );

              //   return (
              //     <Alert
              //       title="Form errors"
              //       withCloseButton
              //       closeButtonLabel="Dismiss"
              //       color="red"
              //     >
              //       <pre>{JSON.stringify(errors, null, 2)}</pre>
              //     </Alert>
              //   );
              // }}
            />
          </Stack>

/////////////////////////////////////////////////

export type TFNValidateFn<TFN, TFormData, TFormValidator extends Validator<TFormData, unknown> | undefined = undefined> = (props: {
  value: TFormData;
  formApi: FormApi<TFormData, TFormValidator>;
}) => FormValidationError<TFormData> | TFN;
 
export type FormValidateOrFn<TFormData, TFormValidator extends Validator<TFormData, unknown> | undefined = undefined> = TFormValidator extends Validator<TFormData, infer TFN> ? TFN | TFNValidateFn<TFN, TFormData, TFormValidator> : FormValidateFn<TFormData, TFormValidator>;


/////////////////////////////////////////////////


export function BasicLogInFormFields() {
  // const { foo } = useBasicLogInForm();
  // console.log(foo);

  return (
    <>
      {/* <UsernameField /> */}
      {/* <PasswordField /> */}
    </>
  );
}

function UsernameField({
  name = "username",
  form,
}: {
  name: string;
  form: any;
}) {
  // const field = useField({ name });
  // const form = useFormCon;
  return (
    <Field form={form} name={name}>
      {({ state, handleChange, handleBlur }) => (
        <input
          onChange={handleChange}
          onBlur={handleBlur}
          defaultValue={state.value as string}
        />
      )}
    </Field>
  );
}

function PasswordField() {
  return <input />;
}

export function Test() {
  const { Field, handleSubmit, state } = useForm({
    defaultValues: {
      firstName: "",
      lastName: "",
      isChecked: false,
    },
    onSubmit: async ({ value }) => {
      // Handle form submission
      console.log(value);
    },
  });

  return (
    <>
      <form
        onSubmit={(e) => {
          e.preventDefault();
          handleSubmit();
        }}
      >
        <Field
          name="firstName"
          children={({ state, handleChange, handleBlur }) => (
            <input
              onChange={(e) => handleChange(e.target.value)}
              onBlur={handleBlur}
              defaultValue={state.value}
            />
          )}
        />
        {/* <Field
            name="isChecked"
            children={({ state, handleChange, handleBlur }) => (
              <Checkbox
                onChange={(e) => handleChange(e.target.checked)}
                onBlur={handleBlur}
                checked={state.value}
              />
            )}
          /> */}
      </form>
      <div>
        <pre>{JSON.stringify(state.values, null, 2)}</pre>
      </div>
    </>
  );
}


/////////////////////////////////////////////////
/////////////////////////////////////////////////



